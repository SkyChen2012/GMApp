/* soapClient.c
   Generated by gSOAP 2.8.15 from soapmsg.h

Copyright(C) 2000-2013, Robert van Engelen, Genivia Inc. All Rights Reserved.
The generated code is released under ONE of the following licenses:
GPL or Genivia's license for commercial use.
This program is released under the GPL with the additional exemption that
compiling, linking, and/or using OpenSSL is allowed.
*/

#if defined(__BORLANDC__)
#pragma option push -w-8060
#pragma option push -w-8004
#endif
#include "soapH.h"
#ifdef __cplusplus
extern "C" {
#endif

SOAP_SOURCE_STAMP("@(#) soapClient.c ver 2.8.15 2013-09-12 08:43:37 GMT")


SOAP_FMAC5 int SOAP_FMAC6 soap_call_ns__SendMsg(struct soap *soap, const char *soap_endpoint, const char *soap_action, struct stMsg in, struct stMsg *out)
{	struct ns__SendMsg soap_tmp_ns__SendMsg;
	struct ns__SendMsgResponse *soap_tmp_ns__SendMsgResponse;
	if (soap_endpoint == NULL)
		soap_endpoint = "http://localhost:2298";
	soap->encodingStyle = "";
	soap_tmp_ns__SendMsg.in = in;
	soap_begin(soap);
	soap_serializeheader(soap);
	soap_serialize_ns__SendMsg(soap, &soap_tmp_ns__SendMsg);
	if (soap_begin_count(soap))
		return soap->error;
	if (soap->mode & SOAP_IO_LENGTH)
	{	if (soap_envelope_begin_out(soap)
		 || soap_putheader(soap)
		 || soap_body_begin_out(soap)
		 || soap_put_ns__SendMsg(soap, &soap_tmp_ns__SendMsg, "ns:SendMsg", NULL)
		 || soap_body_end_out(soap)
		 || soap_envelope_end_out(soap))
			 return soap->error;
	}
	if (soap_end_count(soap))
		return soap->error;
	if (soap_connect(soap, soap_url(soap, soap_endpoint, NULL), soap_action)
	 || soap_envelope_begin_out(soap)
	 || soap_putheader(soap)
	 || soap_body_begin_out(soap)
	 || soap_put_ns__SendMsg(soap, &soap_tmp_ns__SendMsg, "ns:SendMsg", NULL)
	 || soap_body_end_out(soap)
	 || soap_envelope_end_out(soap)
	 || soap_end_send(soap))
		return soap_closesock(soap);
	if (!out)
		return soap_closesock(soap);
	soap_default_stMsg(soap, out);
	if (soap_begin_recv(soap)
	 || soap_envelope_begin_in(soap)
	 || soap_recv_header(soap)
	 || soap_body_begin_in(soap))
		return soap_closesock(soap);
	if (soap_recv_fault(soap, 1))
		return soap->error;
	soap_tmp_ns__SendMsgResponse = soap_get_ns__SendMsgResponse(soap, NULL, "", "");
	if (!soap_tmp_ns__SendMsgResponse || soap->error)
		return soap_recv_fault(soap, 0);
	if (soap_body_end_in(soap)
	 || soap_envelope_end_in(soap)
	 || soap_end_recv(soap))
		return soap_closesock(soap);
	if (out && soap_tmp_ns__SendMsgResponse->out)
		*out = *soap_tmp_ns__SendMsgResponse->out;
	return soap_closesock(soap);
}

SOAP_FMAC5 int SOAP_FMAC6 soap_call_ns__ATTReflash(struct soap *soap, const char *soap_endpoint, const char *soap_action, unsigned int ID, unsigned int IP, unsigned int Port, struct ns__StrPointer TraceName, struct ns__StrPointer *TraceStr)
{	struct ns__ATTReflash soap_tmp_ns__ATTReflash;
	struct ns__ATTReflashResponse *soap_tmp_ns__ATTReflashResponse;
	if (soap_endpoint == NULL)
		soap_endpoint = "http://localhost:2298";
	soap->encodingStyle = "";
	soap_tmp_ns__ATTReflash.ID = ID;
	soap_tmp_ns__ATTReflash.IP = IP;
	soap_tmp_ns__ATTReflash.Port = Port;
	soap_tmp_ns__ATTReflash.TraceName = TraceName;
	soap_begin(soap);
	soap_serializeheader(soap);
	soap_serialize_ns__ATTReflash(soap, &soap_tmp_ns__ATTReflash);
	if (soap_begin_count(soap))
		return soap->error;
	if (soap->mode & SOAP_IO_LENGTH)
	{	if (soap_envelope_begin_out(soap)
		 || soap_putheader(soap)
		 || soap_body_begin_out(soap)
		 || soap_put_ns__ATTReflash(soap, &soap_tmp_ns__ATTReflash, "ns:ATTReflash", NULL)
		 || soap_body_end_out(soap)
		 || soap_envelope_end_out(soap))
			 return soap->error;
	}
	if (soap_end_count(soap))
		return soap->error;
	if (soap_connect(soap, soap_url(soap, soap_endpoint, NULL), soap_action)
	 || soap_envelope_begin_out(soap)
	 || soap_putheader(soap)
	 || soap_body_begin_out(soap)
	 || soap_put_ns__ATTReflash(soap, &soap_tmp_ns__ATTReflash, "ns:ATTReflash", NULL)
	 || soap_body_end_out(soap)
	 || soap_envelope_end_out(soap)
	 || soap_end_send(soap))
		return soap_closesock(soap);
	if (!TraceStr)
		return soap_closesock(soap);
	soap_default_ns__StrPointer(soap, TraceStr);
	if (soap_begin_recv(soap)
	 || soap_envelope_begin_in(soap)
	 || soap_recv_header(soap)
	 || soap_body_begin_in(soap))
		return soap_closesock(soap);
	if (soap_recv_fault(soap, 1))
		return soap->error;
	soap_tmp_ns__ATTReflashResponse = soap_get_ns__ATTReflashResponse(soap, NULL, "", "");
	if (!soap_tmp_ns__ATTReflashResponse || soap->error)
		return soap_recv_fault(soap, 0);
	if (soap_body_end_in(soap)
	 || soap_envelope_end_in(soap)
	 || soap_end_recv(soap))
		return soap_closesock(soap);
	if (TraceStr && soap_tmp_ns__ATTReflashResponse->TraceStr)
		*TraceStr = *soap_tmp_ns__ATTReflashResponse->TraceStr;
	return soap_closesock(soap);
}

SOAP_FMAC5 int SOAP_FMAC6 soap_call_ns__ATTGetSessionID(struct soap *soap, const char *soap_endpoint, const char *soap_action, unsigned int *pID)
{	struct ns__ATTGetSessionID soap_tmp_ns__ATTGetSessionID;
	struct ns__ATTGetSessionIDResponse *soap_tmp_ns__ATTGetSessionIDResponse;
	if (soap_endpoint == NULL)
		soap_endpoint = "http://localhost:2298";
	soap->encodingStyle = "";
	soap_begin(soap);
	soap_serializeheader(soap);
	soap_serialize_ns__ATTGetSessionID(soap, &soap_tmp_ns__ATTGetSessionID);
	if (soap_begin_count(soap))
		return soap->error;
	if (soap->mode & SOAP_IO_LENGTH)
	{	if (soap_envelope_begin_out(soap)
		 || soap_putheader(soap)
		 || soap_body_begin_out(soap)
		 || soap_put_ns__ATTGetSessionID(soap, &soap_tmp_ns__ATTGetSessionID, "ns:ATTGetSessionID", NULL)
		 || soap_body_end_out(soap)
		 || soap_envelope_end_out(soap))
			 return soap->error;
	}
	if (soap_end_count(soap))
		return soap->error;
	if (soap_connect(soap, soap_url(soap, soap_endpoint, NULL), soap_action)
	 || soap_envelope_begin_out(soap)
	 || soap_putheader(soap)
	 || soap_body_begin_out(soap)
	 || soap_put_ns__ATTGetSessionID(soap, &soap_tmp_ns__ATTGetSessionID, "ns:ATTGetSessionID", NULL)
	 || soap_body_end_out(soap)
	 || soap_envelope_end_out(soap)
	 || soap_end_send(soap))
		return soap_closesock(soap);
	if (!pID)
		return soap_closesock(soap);
	soap_default_unsignedInt(soap, pID);
	if (soap_begin_recv(soap)
	 || soap_envelope_begin_in(soap)
	 || soap_recv_header(soap)
	 || soap_body_begin_in(soap))
		return soap_closesock(soap);
	if (soap_recv_fault(soap, 1))
		return soap->error;
	soap_tmp_ns__ATTGetSessionIDResponse = soap_get_ns__ATTGetSessionIDResponse(soap, NULL, "", "");
	if (!soap_tmp_ns__ATTGetSessionIDResponse || soap->error)
		return soap_recv_fault(soap, 0);
	if (soap_body_end_in(soap)
	 || soap_envelope_end_in(soap)
	 || soap_end_recv(soap))
		return soap_closesock(soap);
	if (pID && soap_tmp_ns__ATTGetSessionIDResponse->pID)
		*pID = *soap_tmp_ns__ATTGetSessionIDResponse->pID;
	return soap_closesock(soap);
}

SOAP_FMAC5 int SOAP_FMAC6 soap_call_ns__ATTGetTraceName(struct soap *soap, const char *soap_endpoint, const char *soap_action, unsigned int IP, unsigned int Port, struct stStrList *out)
{	struct ns__ATTGetTraceName soap_tmp_ns__ATTGetTraceName;
	struct ns__ATTGetTraceNameResponse *soap_tmp_ns__ATTGetTraceNameResponse;
	if (soap_endpoint == NULL)
		soap_endpoint = "http://localhost:2298";
	soap->encodingStyle = "";
	soap_tmp_ns__ATTGetTraceName.IP = IP;
	soap_tmp_ns__ATTGetTraceName.Port = Port;
	soap_begin(soap);
	soap_serializeheader(soap);
	soap_serialize_ns__ATTGetTraceName(soap, &soap_tmp_ns__ATTGetTraceName);
	if (soap_begin_count(soap))
		return soap->error;
	if (soap->mode & SOAP_IO_LENGTH)
	{	if (soap_envelope_begin_out(soap)
		 || soap_putheader(soap)
		 || soap_body_begin_out(soap)
		 || soap_put_ns__ATTGetTraceName(soap, &soap_tmp_ns__ATTGetTraceName, "ns:ATTGetTraceName", NULL)
		 || soap_body_end_out(soap)
		 || soap_envelope_end_out(soap))
			 return soap->error;
	}
	if (soap_end_count(soap))
		return soap->error;
	if (soap_connect(soap, soap_url(soap, soap_endpoint, NULL), soap_action)
	 || soap_envelope_begin_out(soap)
	 || soap_putheader(soap)
	 || soap_body_begin_out(soap)
	 || soap_put_ns__ATTGetTraceName(soap, &soap_tmp_ns__ATTGetTraceName, "ns:ATTGetTraceName", NULL)
	 || soap_body_end_out(soap)
	 || soap_envelope_end_out(soap)
	 || soap_end_send(soap))
		return soap_closesock(soap);
	if (!out)
		return soap_closesock(soap);
	soap_default_stStrList(soap, out);
	if (soap_begin_recv(soap)
	 || soap_envelope_begin_in(soap)
	 || soap_recv_header(soap)
	 || soap_body_begin_in(soap))
		return soap_closesock(soap);
	if (soap_recv_fault(soap, 1))
		return soap->error;
	soap_tmp_ns__ATTGetTraceNameResponse = soap_get_ns__ATTGetTraceNameResponse(soap, NULL, "", "");
	if (!soap_tmp_ns__ATTGetTraceNameResponse || soap->error)
		return soap_recv_fault(soap, 0);
	if (soap_body_end_in(soap)
	 || soap_envelope_end_in(soap)
	 || soap_end_recv(soap))
		return soap_closesock(soap);
	if (out && soap_tmp_ns__ATTGetTraceNameResponse->out)
		*out = *soap_tmp_ns__ATTGetTraceNameResponse->out;
	return soap_closesock(soap);
}

SOAP_FMAC5 int SOAP_FMAC6 soap_call_ns__ATTGetAnalyseName(struct soap *soap, const char *soap_endpoint, const char *soap_action, unsigned int IP, unsigned int Port, struct stStrList *out)
{	struct ns__ATTGetAnalyseName soap_tmp_ns__ATTGetAnalyseName;
	struct ns__ATTGetAnalyseNameResponse *soap_tmp_ns__ATTGetAnalyseNameResponse;
	if (soap_endpoint == NULL)
		soap_endpoint = "http://localhost:2298";
	soap->encodingStyle = "";
	soap_tmp_ns__ATTGetAnalyseName.IP = IP;
	soap_tmp_ns__ATTGetAnalyseName.Port = Port;
	soap_begin(soap);
	soap_serializeheader(soap);
	soap_serialize_ns__ATTGetAnalyseName(soap, &soap_tmp_ns__ATTGetAnalyseName);
	if (soap_begin_count(soap))
		return soap->error;
	if (soap->mode & SOAP_IO_LENGTH)
	{	if (soap_envelope_begin_out(soap)
		 || soap_putheader(soap)
		 || soap_body_begin_out(soap)
		 || soap_put_ns__ATTGetAnalyseName(soap, &soap_tmp_ns__ATTGetAnalyseName, "ns:ATTGetAnalyseName", NULL)
		 || soap_body_end_out(soap)
		 || soap_envelope_end_out(soap))
			 return soap->error;
	}
	if (soap_end_count(soap))
		return soap->error;
	if (soap_connect(soap, soap_url(soap, soap_endpoint, NULL), soap_action)
	 || soap_envelope_begin_out(soap)
	 || soap_putheader(soap)
	 || soap_body_begin_out(soap)
	 || soap_put_ns__ATTGetAnalyseName(soap, &soap_tmp_ns__ATTGetAnalyseName, "ns:ATTGetAnalyseName", NULL)
	 || soap_body_end_out(soap)
	 || soap_envelope_end_out(soap)
	 || soap_end_send(soap))
		return soap_closesock(soap);
	if (!out)
		return soap_closesock(soap);
	soap_default_stStrList(soap, out);
	if (soap_begin_recv(soap)
	 || soap_envelope_begin_in(soap)
	 || soap_recv_header(soap)
	 || soap_body_begin_in(soap))
		return soap_closesock(soap);
	if (soap_recv_fault(soap, 1))
		return soap->error;
	soap_tmp_ns__ATTGetAnalyseNameResponse = soap_get_ns__ATTGetAnalyseNameResponse(soap, NULL, "", "");
	if (!soap_tmp_ns__ATTGetAnalyseNameResponse || soap->error)
		return soap_recv_fault(soap, 0);
	if (soap_body_end_in(soap)
	 || soap_envelope_end_in(soap)
	 || soap_end_recv(soap))
		return soap_closesock(soap);
	if (out && soap_tmp_ns__ATTGetAnalyseNameResponse->out)
		*out = *soap_tmp_ns__ATTGetAnalyseNameResponse->out;
	return soap_closesock(soap);
}

SOAP_FMAC5 int SOAP_FMAC6 soap_call_ns__ATTGetAnalyse(struct soap *soap, const char *soap_endpoint, const char *soap_action, unsigned int IP, unsigned int Port, struct ns__StrPointer AnalyseName, struct ns__StrPointer *AnalyseStr)
{	struct ns__ATTGetAnalyse soap_tmp_ns__ATTGetAnalyse;
	struct ns__ATTGetAnalyseResponse *soap_tmp_ns__ATTGetAnalyseResponse;
	if (soap_endpoint == NULL)
		soap_endpoint = "http://localhost:2298";
	soap->encodingStyle = "";
	soap_tmp_ns__ATTGetAnalyse.IP = IP;
	soap_tmp_ns__ATTGetAnalyse.Port = Port;
	soap_tmp_ns__ATTGetAnalyse.AnalyseName = AnalyseName;
	soap_begin(soap);
	soap_serializeheader(soap);
	soap_serialize_ns__ATTGetAnalyse(soap, &soap_tmp_ns__ATTGetAnalyse);
	if (soap_begin_count(soap))
		return soap->error;
	if (soap->mode & SOAP_IO_LENGTH)
	{	if (soap_envelope_begin_out(soap)
		 || soap_putheader(soap)
		 || soap_body_begin_out(soap)
		 || soap_put_ns__ATTGetAnalyse(soap, &soap_tmp_ns__ATTGetAnalyse, "ns:ATTGetAnalyse", NULL)
		 || soap_body_end_out(soap)
		 || soap_envelope_end_out(soap))
			 return soap->error;
	}
	if (soap_end_count(soap))
		return soap->error;
	if (soap_connect(soap, soap_url(soap, soap_endpoint, NULL), soap_action)
	 || soap_envelope_begin_out(soap)
	 || soap_putheader(soap)
	 || soap_body_begin_out(soap)
	 || soap_put_ns__ATTGetAnalyse(soap, &soap_tmp_ns__ATTGetAnalyse, "ns:ATTGetAnalyse", NULL)
	 || soap_body_end_out(soap)
	 || soap_envelope_end_out(soap)
	 || soap_end_send(soap))
		return soap_closesock(soap);
	if (!AnalyseStr)
		return soap_closesock(soap);
	soap_default_ns__StrPointer(soap, AnalyseStr);
	if (soap_begin_recv(soap)
	 || soap_envelope_begin_in(soap)
	 || soap_recv_header(soap)
	 || soap_body_begin_in(soap))
		return soap_closesock(soap);
	if (soap_recv_fault(soap, 1))
		return soap->error;
	soap_tmp_ns__ATTGetAnalyseResponse = soap_get_ns__ATTGetAnalyseResponse(soap, NULL, "", "");
	if (!soap_tmp_ns__ATTGetAnalyseResponse || soap->error)
		return soap_recv_fault(soap, 0);
	if (soap_body_end_in(soap)
	 || soap_envelope_end_in(soap)
	 || soap_end_recv(soap))
		return soap_closesock(soap);
	if (AnalyseStr && soap_tmp_ns__ATTGetAnalyseResponse->AnalyseStr)
		*AnalyseStr = *soap_tmp_ns__ATTGetAnalyseResponse->AnalyseStr;
	return soap_closesock(soap);
}

#ifdef __cplusplus
}
#endif

#if defined(__BORLANDC__)
#pragma option pop
#pragma option pop
#endif

/* End of soapClient.c */
